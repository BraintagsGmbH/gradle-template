// properties
def skipTests          = rootProject.hasProperty('skipTests')?rootProject.skipTests:'false'
def skipTestJar        = rootProject.hasProperty('skipTestJar')?rootProject.skipTestJar:'false'
def ignoreFailedTest   = rootProject.hasProperty('ignoreFailedTest')?rootProject.ignoreFailedTest:false
def skipSonar          = rootProject.hasProperty('skipSonar')?rootProject.skipSonar:'false'

buildscript {
  repositories {
    maven {
      url 'https://plugins.gradle.org/m2/'
    }
  }
  dependencies {
    classpath "org.sonarsource.scanner.gradle:sonarqube-gradle-plugin:2.2"
  }
}

dependencies {
    testCompile group: 'junit', name: 'junit', version:'4.11'
    testCompile group: 'org.sonarsource.java', name: 'sonar-jacoco-listeners', version:'3.8'
}

apply plugin: 'jacoco'
apply plugin: org.sonarqube.gradle.SonarQubePlugin

project.tasks["sonarqube"].onlyIf {skipSonar == 'false'}

test {
  useJUnit()

   systemProperty 'io.netty.leakDetectionLevel', 'PARANOID'

  if (hasProperty('mailClientUserName')){
   systemProperty 'mailClientUserName', mailClientUserName
   systemProperty 'mailClientPassword', mailClientPassword
  }

  test.ignoreFailures = ignoreFailedTest

  // show standard out and standard error of the test JVM(s) on the console
  testLogging.showStandardStreams = true

  // set heap size for the test JVM(s)
  minHeapSize = "128m"
  maxHeapSize = "1200M"

  jvmArgs '-server'

  // listen to events in the test execution lifecycle
  beforeTest { descriptor ->
     logger.lifecycle("Running test: " + descriptor)
  }


  include '**/*TestAll*'

  // listen to standard out and standard error of the test JVM(s)
  onOutput { descriptor, event ->
     logger.lifecycle("Test: " + descriptor + " produced standard out/err: " + event.message )
  }

}
test.onlyIf {skipTests == 'false'}

task testjar(type: Jar, group: 'distribution', description: 'Create a jar containing all the javadocs'){
    classifier = 'tests'
	  from sourceSets.test.allSource
}
testjar.onlyIf {skipTestJar=='false'}
