apply plugin: 'java'

sourceCompatibility = rootProject.hasProperty('sourceCompatibility')?rootProject.sourceCompatibility:'8'
targetCompatibility = rootProject.hasProperty('targetCompatibility')?rootProject.targetCompatibility:'8'
compileJava.options.encoding = rootProject.hasProperty('sourceEncoding')?rootProject.sourceEncoding:'UTF-8'

ext.githubProjectName = rootProject.name // Set this if Project name is not github name

// properties
def skipDoc            = rootProject.hasProperty('skipDoc')?rootProject.skipDoc:'false'
def javadocFileInclude = rootProject.hasProperty('javadocFileInclude')?rootProject.javadocFileInclude:'de/braintags/**/*.java'
def useCompanyRepo     = rootProject.hasProperty('useCompanyRepo')?rootProject.useCompanyRepo:true
def multiProject       = rootProject.hasProperty('multiProject')?rootProject.multiProject:false

// set git version hash
def versionOut = new ByteArrayOutputStream()
exec {
    workingDir =  project.projectDir
    commandLine 'git', 'log' ,'-n' ,'1' , '--date=short','--no-merges', '--pretty=%cd_%h', '.'
    standardOutput = versionOut
}

buildscript {
  def useCompanyRepo     = rootProject.hasProperty('useCompanyRepo')?rootProject.useCompanyRepo:true
  repositories {
    if(useCompanyRepo) { // set useCompanyRepo=false in ~/.gradle/gradle.properties to disable
      maven {
        url 'https://nexus.ps.bt.systems/repository/gradle/'
      }
    }
    	  mavenCentral()
	  jcenter()
    maven {
      url 'https://plugins.gradle.org/m2/'
    }
  }
  dependencies {
    classpath 'com.netflix.nebula:gradle-dependency-lock-plugin:4.3.0'
  }
}


repositories {
  // private company repo makes no sense in an opensource environment
  if(useCompanyRepo) { // set useCompanyRepo=false in ~/.gradle/gradle.properties to disable
    maven {
      url 'https://nexus.ps.bt.systems/repository/maven-central-releases/'
    }
  } else {
	  mavenCentral()
	  jcenter()
  }
}

apply plugin: nebula.plugin.dependencylock.DependencyLockPlugin

dependencyLock {
  globalLockFile = project.rootDir.toURI().relativize(new File(projectDir.getAbsolutePath() + '/global.lock').toURI()).getPath()
}

apply from: file(rootDir.path + '/gradle/test.gradle')
apply from: file(rootDir.path + '/gradle/maven.gradle')

if (!multiProject) { // This need to be applied in the root project
  apply from: file(rootDir.path + '/gradle/sonar.gradle')
  apply from: file(rootDir.path + '/gradle/release.gradle')
}

ext.sharedManifest = manifest {
  attributes('Implementation-Title': project.artifactid,
             'Implementation-Version': version)
}

javadoc {
  source = sourceSets.main.allJava
  classpath = project.sourceSets.main.compileClasspath
  include javadocFileInclude
  failOnError = false
  options.addStringOption('-quiet')
}
javadoc.onlyIf {skipDoc == 'false'}

task javadocJar(type: Jar, dependsOn: javadoc, group: 'distribution', description: 'Create a jar containing all the javadocs'){
  manifest = project.manifest {
    from sharedManifest
  }
  from javadoc.destinationDir
  classifier = 'javadoc'
  extension 'jar'
}
javadocJar.onlyIf {skipDoc == 'false'}

jar {
  manifest = project.manifest {
    from sharedManifest
  }
  exclude '/docoverride/**'
  exclude '/examples/**'
}

task sourcesJar(type: Jar, dependsOn: classes, group: 'distribution', description: 'Create a jar containing all the sources') {
  manifest = project.manifest {
    from sharedManifest
  }
  classifier = 'sources'
  from sourceSets.main.allSource
}

artifacts {
  archives sourcesJar
  archives jar
  archives testjar
  archives javadocJar
}

// Generate wrapper, which is distributed as part of source to alleviate the need of installing gradle
task createWrapper(type: Wrapper) {
  gradleVersion = '3.5'
}
